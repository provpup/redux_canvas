<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas id="drawingArea"></canvas>
  <ul>
    <li><button onclick='switchRectangle()'>Rectangle</button></li>
    <li><button>Ellipse</button></li>
    <li><button>Lasso</button></li>
  </ul>
  <script>
    const RECTANGLE_MODE = 'rectangle';
    const ELLIPSE_MODE = 'ellipse';
    const LASSO_MODE = 'lasso';

    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext("2d");
    const initialState = {
      canvas: { x: 0, y: 0 },
      items: [
        // { id: 1, x: 10, y: 10, width: 50, height: 50, color: 'red' },
        // { id: 2, x: 30, y: 30, width: 50, height: 50, color: 'blue' }
      ],
      xDragging: null,
      yDragging: null,
      draggingItemId: null,
      drawingShape: '',
      drawingMode: false,
      currentDrawingShapeInstance: ''
    };

    function reducer(state, action) {
      if (state !== undefined) {
        const {canvas, items, draggingItemId} = state;
        const {id, type, xDragging, yDragging, drawingShape, drawingMode, initialX, initialY, currentX = initialX, currentY = initialY, currentDrawingShapeInstance} = action;
        console.log('reducer received action:', type);
        switch (type) {
          case 'TRANSLATE_CANVAS_START':
            return {canvas, items, xDragging, yDragging, draggingItemId: null};
          case 'TRANSLATE_CANVAS':
            return {
              canvas: {
                x: canvas.x + xDragging - state.xDragging,
                y: canvas.y + yDragging - state.yDragging
              },
              items, xDragging, yDragging, draggingItemId: null
            };
          case 'TRANSLATE_CANVAS_END':
            return {canvas, items, xDragging: null, yDragging: null, draggingItemId: null};
          case 'TRANSLATE_ITEM_START':
            return {canvas, items, xDragging, yDragging, draggingItemId: id};
          case 'TRANSLATE_ITEM':
            const newItems = items.map(function(item) {
              if (item.id === draggingItemId) {
                return {
                  id: item.id,
                  x: item.x + xDragging - state.xDragging,
                  y: item.y + yDragging - state.yDragging,
                  width: item.width,
                  height: item.height,
                  color: item.color
                };
              } else {
                return item;
              }
            });
            return {canvas, items: newItems, xDragging, yDragging, draggingItemId};
          case 'TRANSLATE_ITEM_END':
            return {canvas, items, xDragging: null, yDragging: null, draggingItemId: null};
          case 'SHAPE_MODE':
             return {...state, drawingShape};
          case 'DRAWING_MODE':
            return {...state, drawingMode};
          case 'ADD_SHAPE':
            const newShape = {createdAt: Date.now(), shape: state.drawingShape, initialX, initialY, currentX, currentY};
            return {...state, items: items.concat(newShape), currentDrawingShapeInstance: newShape.createdAt};
          case 'RESIZE_SHAPE':
            // Get the current shape based on the saved timestamp
            const currentShape = state.items.find(shape => shape.createdAt === state.currentDrawingShapeInstance);
            // We want to change the currentX and currentY for this shape in a functional way;
            // so we filter out the current shape from our list of shapes, and then add a new revised copy of our current shape with the new coordinates
            return {...state, items: state.items.filter(shape => shape.createdAt !== currentDrawingShapeInstance).concat({...currentShape, currentX, currentY})}
          default:
            return state;
        }
      } else {
        return initialState;
      }
    }

    const shapeRenderers = {
      [RECTANGLE_MODE]: function  (context, rectangle)  {
        console.log('rectangle:', rectangle);
        const width = Math.abs(rectangle.currentX - rectangle.initialX);
        const height = Math.abs(rectangle.currentY - rectangle.initialY);
        context.fillStyle = 'red';
        context.fillRect(rectangle.initialX, rectangle.initialY, width, height);
      },
      [ELLIPSE_MODE]: function(context, ellipse) {

      },
      [LASSO_MODE]: function(context, lasso) {

      }
    };

    function byTimestamp(a, b) {
      return a.createdAt -  b.createdAt;
    }

    function draw() {
      const state = store.getState();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      state.items.sort(byTimestamp).forEach(function(item) {
        shapeRenderers[item.shape](ctx, item);
      });
    }


    const store = Redux.createStore(reducer);
    store.subscribe(draw);


    function switchRectangle() {
      store.dispatch({type: 'SHAPE_MODE', drawingShape: RECTANGLE_MODE});
    }

    canvas.addEventListener('mousedown', function(event) {
      store.dispatch({type: 'DRAWING_MODE', drawingMode: true});

      const state = store.getState();
      console.log('drawing shape:', state.drawingShape);
      console.log('drawing mode:', state.drawingMode);
      store.dispatch({type: 'ADD_SHAPE', initialX: event.offsetX, initialY: event.offsetY});
      // for (var i = state.items.length - 1; i >= 0; i--) {
      //   var item = state.items[i];
      //   ctx.beginPath();
      //   ctx.rect(item.x, item.y, item.width, item.height);
      //   if (ctx.isPointInPath(event.offsetX, event.offsetY)) {
      //     store.dispatch({
      //       type: 'TRANSLATE_ITEM_START',
      //       id: item.id,
      //       xDragging: event.offsetX,
      //       yDragging: event.offsetY
      //     });
      //     return;
      //   }
      // }
      // store.dispatch({
      //   type: 'TRANSLATE_CANVAS_START',
      //   xDragging: event.offsetX,
      //   yDragging: event.offsetY
      // });
    }, false);

    canvas.addEventListener('mousemove', function(event) {
      const state = store.getState();
      if (state.drawingMode) {
        store.dispatch({type: 'RESIZE_SHAPE', currentX: event.offsetX, currentY: event.offsetY});
      }

      // if (state.draggingItemId !== null) {
      //   store.dispatch({
      //     type: 'TRANSLATE_ITEM',
      //     xDragging: event.offsetX,
      //     yDragging: event.offsetY
      //   });
      // } else if (state.xDragging !== null && state.yDragging !== null) {
      //   store.dispatch({
      //     type: 'TRANSLATE_CANVAS',
      //     xDragging: event.offsetX,
      //     yDragging: event.offsetY
      //   });
      // }
    }, false);

    canvas.addEventListener('mouseup', function(event) {
      store.dispatch({type: 'DRAWING_MODE', drawingMode: false});
      const state = store.getState();
      store.dispatch({type: state.draggingItemId !== null ? 'TRANSLATE_ITEM_END' : 'TRANSLATE_CANVAS_END'});
      console.log('mouse up - drawing mode:', state.drawingMode);
    }, false);

    draw();
</script>
</body>
</html>

