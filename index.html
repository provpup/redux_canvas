<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas width="600" height="400" id="drawingArea"  style="background: url('./cat_caviar.jpg')"></canvas>
  <ul>
    <li><button onclick='switchLine()'>Line</button></li>
    <li><button onclick='switchRectangle()'>Rectangle</button></li>
    <li><button onclick='switchEllipse()'>Ellipse</button></li>
    <li><button onclick='switchLasso()'>Lasso</button></li>
    <li><button onclick='switchSelect()'>Select</button></li>
  </ul>
  <script>

    const RECTANGLE_MODE = 'rectangle';
    const ELLIPSE_MODE = 'ellipse';
    const LASSO_MODE = 'lasso';
    const LINE_MODE = 'line';

    const handleHitBox = 10;
    let currentShape;

    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext('2d');

    const shapeResize = {
      [LINE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [RECTANGLE_MODE](source, currentX, currentY, corner) {
        if (corner === 'TL') {
          return { ...source, initialX: currentX, currentY };
        } else if (corner === 'BR') {
          return { ...source, currentX, initialY: currentY };
        } else if (corner === 'BL') {
          return { ...source, initialX: currentX, initialY: currentY };
        }
        return { ...source, currentX, currentY };
      },
      [ELLIPSE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [LASSO_MODE](source, currentX, currentY) {
        return { ...source, points: (source.points || []).concat({ x: currentX, y: currentY }) };
      },
    };

    const shapeTranslate = {
      [LINE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const { initialX, initialY, currentX, currentY } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference
        };
      },
      [RECTANGLE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const { initialX, initialY, currentX, currentY } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference
        };
      },
      [ELLIPSE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const { initialX, initialY, currentX, currentY } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference
        };
      },
      [LASSO_MODE](source, xDraggingDifference, yDraggingDifference) {
        const { initialX, initialY, points } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          points: points.map(point => ({ x: point.x + xDraggingDifference, y: point.y + yDraggingDifference })),
        };
      },
    };

    const initialState = {
      activeSelection: null,
      canvas: { x: 0, y: 0 },
      currentDrawingShapeInstance: '',
      dragBL: false,
      dragBR: false,
      dragTL: false,
      dragTR: false,
      dragMiddle: false,
      draggingItemId: null,
      drawingShape: '',
      drawingMode: false,
      items: [],
      xDragging: null,
      yDragging: null,
    };

    function reducer(state, action) {
      if (state !== undefined) {
        const {
          canvas,
          currentDrawingShapeInstance,
          draggingItemId,
          items,
        } = state;
        const {
          activeSelection,
          initialX,
          initialY,
          corner,
          currentX = initialX,
          currentY = initialY,
          dragging,
          dragMiddle,
          drawingShape,
          drawingMode,
          handle,
          id,
          type,
          xDragging,
          yDragging,
        } = action;
        switch (type) {
        case 'SHAPE_MODE':
          return { ...state, drawingShape };
        case 'DRAWING_MODE':
          return { ...state, drawingMode };
        case 'DRAG_CORNER_HANDLE':
          return { ...state, [handle]: dragging }
        case 'DRAG_MIDDLE_HANDLE':
          return { ...state, dragMiddle }
        case 'ADD_SHAPE':
          const newShape = {
            createdAt: Date.now(), shape: state.drawingShape, initialX, initialY,
          };
          return { ...state, items: items.concat(newShape), currentDrawingShapeInstance: newShape.createdAt };
        case 'RESIZE_SHAPE':
          // Get the current shape based on the saved timestamp
          currentShape = items.find(shape => shape.createdAt === currentDrawingShapeInstance);
          // We want to change the currentX and currentY for this shape in a functional way;
          // so we filter out the current shape from our list of shapes, and then add a new revised copy of our current shape with the new coordinates
          return { ...state, items: items.filter(shape => shape.createdAt !== currentDrawingShapeInstance).concat(shapeResize[currentShape.shape](currentShape, currentX, currentY)) };
        case 'RESIZE_RECT_OR_ELLIPSE':
          currentShape = items.find(shape => shape.createdAt === state.activeSelection.createdAt);
          return { ...state, items: items.filter(shape => shape.createdAt !== currentShape.createdAt).concat(shapeResize[RECTANGLE_MODE](currentShape, currentX, currentY, corner)) };
        case 'SET_ACTIVE':
          return { ...state, activeSelection };
        case 'TRANSLATE_ITEM_START':
          return {
            ...state,
            xDragging,
            yDragging,
            draggingItemId: id,
          };
        case 'TRANSLATE_ITEM':
          currentShape = items.find(shape => shape.createdAt === state.activeSelection.createdAt);
          return {
            ...state,
            xDragging,
            yDragging,
            draggingItemId,
            items: items
              .filter(shape => shape.createdAt !== currentShape.createdAt)
              .concat(shapeTranslate[currentShape.shape](currentShape, xDragging - state.xDragging, yDragging - state.yDragging))
          };
        case 'TRANSLATE_ITEM_END':
          return {
            ...state,
            xDragging: null,
            yDragging: null,
            draggingItemId: null,
          };
        default:
          return state;
        }
      } else {
        return initialState;
      }
    }

    const shapeRenderers = {
      [LINE_MODE](context, line) {
        const { initialX, initialY, currentX, currentY } = line;
        context.save();
        context.moveTo(initialX, initialY);
        context.lineTo(currentX, currentY);
        context.lineWidth = 3;
        context.strokeStyle = 'green';
        context.stroke();
        context.restore();
      },
      [RECTANGLE_MODE](context, rectangle) {
        const { initialX, initialY, currentX, currentY } = rectangle;
        const width = currentX - initialX;
        const height = currentY - initialY;
        context.save()
        context.rect(initialX, initialY, width, height);
        context.lineWidth = 3;
        context.strokeStyle = 'red';
        context.stroke();
        context.restore();
      },
      [ELLIPSE_MODE](context, ellipse) {
        const { initialX, initialY, currentX, currentY } = ellipse;
        const scalex = 1 * ((currentX-initialX) / 2);
        const scaley = 1 * ((currentY-initialY) / 2);
        const centerx = (initialX / scalex) + 1;
        const centery = (initialY / scaley) + 1;
        context.save();
        context.scale(scalex, scaley);
        context.arc(centerx, centery, 1, 0, 2 * Math.PI);
        context.restore();
        context.save();
        context.strokeStyle = 'blue';
        context.lineWidth = 4;
        context.stroke();
        context.restore();
      },
      [LASSO_MODE](context, lasso) {
        const { initialX, initialY, points = [] } = lasso;
        const coordinates = points.map(Object.values).flat();
        for (let count = 0; count < coordinates.length; count += 2) {
          context.lineTo(coordinates[count], coordinates[count + 1]);
        }
        context.save();
        context.lineWidth = 2;
        context.strokeStyle = 'black';
        context.fillStyle = 'rgb(0, 0, 0, 0.4)';
        context.closePath();
        context.fill();
        context.restore();
      },
    };

    function byTimestamp(a, b) {
      return a.createdAt - b.createdAt;
    }

    function checkHandleHitBox(p1, p2) {
        return Math.abs(p1 - p2) < 20;
    }

    function checkCorners(event, item) {
      const state = store.getState();
      const { initialX, initialY, currentX, currentY } = item;
      const { offsetX, offsetY } = event;
      if (state.activeSelection && state.activeSelection.createdAt === item.createdAt) {
        if (checkHandleHitBox(offsetX, initialX) && checkHandleHitBox(offsetY, initialY)) {
          store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragBL', dragging: true });
          return;
        } else if (checkHandleHitBox(offsetX, currentX) && checkHandleHitBox(offsetY, initialY)) {
          store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragBR', dragging: true });
          return;
        } else if (checkHandleHitBox(offsetX, initialX) && checkHandleHitBox(offsetY, currentY)) {
          store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragTL', dragging: true });
          return;
        } else if (checkHandleHitBox(offsetX, currentX) && checkHandleHitBox(offsetY, currentY)) {
          store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragTR', dragging: true });
          return;
        } else if (checkHandleHitBox(offsetX, (currentX + initialX) / 2) && checkHandleHitBox(offsetY, (currentY + initialY) /2)) {
          store.dispatch({
              type: 'TRANSLATE_ITEM_START',
              id: item.createdAt,
              xDragging: offsetX,
              yDragging: offsetY,
            });
          return;
        }
      }
    }

    function drawRectangleEllipseHandles(state, item) {
      const { initialX, initialY, currentX, currentY, createdAt, shape } = item;
      if (state.activeSelection && createdAt === state.activeSelection.createdAt && (shape === 'rectangle' || shape === 'ellipse' || shape === 'line')) {
        drawCircle(initialX, initialY, handleHitBox); // bottom left
        drawCircle(currentX, currentY, handleHitBox); // top right
        drawCircle(currentX, initialY, handleHitBox); // bottom right
        drawCircle(initialX, currentY, handleHitBox); // top left
        drawSquare(((currentX + initialX) /2) - 10, ((currentY + initialY) /2) - 10); // middle
      }
    }

    function drawCircle(x, y, radius) {
      ctx.fillStyle = "#FF0000";
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawSquare(x, y) {
      ctx.fillStyle = "#FF0000";
      ctx.beginPath();
      ctx.fillRect(x, y, 20, 20);
    }

    function draw() {
      const state = store.getState();
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      state.items.sort(byTimestamp).forEach((item) => {
        ctx.beginPath();
        shapeRenderers[item.shape](ctx, item);
        drawRectangleEllipseHandles(state, item);
      });
    }

    const store = Redux.createStore(reducer);
    store.subscribe(draw);

    function switchLine() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: LINE_MODE });
    }

    function switchRectangle() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: RECTANGLE_MODE });
    }

    function switchEllipse() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: ELLIPSE_MODE });
    }

    function switchLasso() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: LASSO_MODE });
    }

    function switchSelect() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: '' });
    }

    canvas.addEventListener('mousedown', (event) => {
      const { offsetX, offsetY } = event;
      const state = store.getState();
      store.dispatch({ type: 'DRAWING_MODE', drawingMode: true });
      if (state.drawingShape) {
        // Start creating a shape
        store.dispatch({ type: 'ADD_SHAPE', initialX: offsetX, initialY: offsetY });
        return;
      }
      // Select and drag shapes
      for (let i = state.items.length - 1; i >= 0; i--) {
        const item = state.items[i];
        checkCorners(event, item);
        ctx.beginPath();
        shapeRenderers[item.shape](ctx, item);
        if (ctx.isPointInPath(offsetX, offsetY) || ctx.isPointInStroke(offsetX, offsetY)) {
          store.dispatch({
            type: 'SET_ACTIVE',
            activeSelection: item,
          });
          return;
        }
      }
    }, false);

    canvas.addEventListener('mousemove', (event) => {
      const state = store.getState();
      const { dragBL, dragBR, dragTL, dragTR, dragMiddle } = state;
      const { offsetX, offsetY } = event;
      if (dragTR) {
        store.dispatch({ type: 'RESIZE_RECT_OR_ELLIPSE', currentX: offsetX, currentY: offsetY, corner: 'TR'});
        return;
      }
      if (dragTL) {
        store.dispatch({ type: 'RESIZE_RECT_OR_ELLIPSE', currentX: offsetX, currentY: offsetY, corner: 'TL'});
        return;
      }
      if (dragBL) {
        store.dispatch({ type: 'RESIZE_RECT_OR_ELLIPSE', currentX: offsetX, currentY: offsetY, corner: 'BL'});
        return;
      }
      if (dragBR) {
        store.dispatch({ type: 'RESIZE_RECT_OR_ELLIPSE', currentX: offsetX, currentY: offsetY, corner: 'BR'});
        return;
      }
      if (state.drawingMode && state.drawingShape) {
        store.dispatch({ type: 'RESIZE_SHAPE', currentX: offsetX, currentY: offsetY });
      } else if (state.draggingItemId !== null) {
        store.dispatch({
          type: 'TRANSLATE_ITEM',
          xDragging: offsetX,
          yDragging: offsetY,
        });
      }
    }, false);

    canvas.addEventListener('mouseup', () => {
      const state = store.getState();
      store.dispatch({ type: 'TRANSLATE_ITEM_END' });
      store.dispatch({ type: 'DRAWING_MODE', drawingMode: false });
      store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragTR', dragging: false });
      store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragTL', dragging: false });
      store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragBR', dragging: false });
      store.dispatch({ type: 'DRAG_CORNER_HANDLE', handle: 'dragBL', dragging: false });
      store.dispatch({ type: 'DRAG_MIDDLE_HANDLE', dragMiddle: false });
      // TODO: if we need to immediately  store the shape, then export newly created shape as event
    }, false);

    draw();
    </script>
  </body>
</html>