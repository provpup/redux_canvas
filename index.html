<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas id="drawingArea"></canvas>
  <ul>
    <li><button onclick='switchRectangle()'>Rectangle</button></li>
    <li><button onclick='switchEllipse()'>Ellipse</button></li>
    <li><button onclick='switchLasso()'>Lasso</button></li>
  </ul>
  <script>
    const RECTANGLE_MODE = 'rectangle';
    const ELLIPSE_MODE = 'ellipse';
    const LASSO_MODE = 'lasso';

    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext("2d");
    const initialState = {
      canvas: { x: 0, y: 0 },
      items: [],
      xDragging: null,
      yDragging: null,
      draggingItemId: null,
      drawingShape: '',
      drawingMode: false,
      currentDrawingShapeInstance: ''
    };

const shapeCopy = {
  [RECTANGLE_MODE]: function (source, currentX, currentY) {
    return {...source, currentX, currentY};
  },
  [ELLIPSE_MODE]: function (source, currentX, currentY) {
    return {...source, currentX, currentY};
  },
  [LASSO_MODE]: function (source, currentX, currentY) {
    console.log('creating lasso copy:', arguments);
    return {...source, points: (source.points || []).concat({x: currentX, y: currentY})};
  }
};

    function reducer(state, action) {
      if (state !== undefined) {
        const {canvas, items, draggingItemId} = state;
        const {id, type, xDragging, yDragging, drawingShape, drawingMode, initialX, initialY, currentX = initialX, currentY = initialY, currentDrawingShapeInstance} = action;
        console.log('reducer received action:', type);
        switch (type) {
          case 'SHAPE_MODE':
             return {...state, drawingShape};
          case 'DRAWING_MODE':
            return {...state, drawingMode};
          case 'ADD_SHAPE':
            const newShape = {createdAt: Date.now(), shape: state.drawingShape, initialX, initialY, currentX, currentY};
            return {...state, items: items.concat(newShape), currentDrawingShapeInstance: newShape.createdAt};
          case 'RESIZE_SHAPE':
            // Get the current shape based on the saved timestamp
            const currentShape = state.items.find(shape => shape.createdAt === state.currentDrawingShapeInstance);
            // We want to change the currentX and currentY for this shape in a functional way;
            // so we filter out the current shape from our list of shapes, and then add a new revised copy of our current shape with the new coordinates
            return {...state, items: state.items.filter(shape => shape.createdAt !== state.currentDrawingShapeInstance).concat(shapeCopy[currentShape.shape](currentShape, currentX, currentY))}
          default:
            return state;
        }
      } else {
        return initialState;
      }
    }

    const shapeRenderers = {
      [RECTANGLE_MODE]: function  (context, rectangle)  {
        console.log('rectangle:', rectangle);
        const { initialX, initialY, currentX, currentY} = rectangle;
        const width = currentX - initialX;
        const height = currentY - initialY;
        context.lineWidth = 3;
        context.strokeStyle = 'red';
        context.strokeRect(initialX, initialY, width, height);
      },
      [ELLIPSE_MODE]: function(context, ellipse) {
        const { initialX, initialY, currentX, currentY} = ellipse;
        console.log('ellpse:', ellipse);
        const radius = Math.hypot(currentX - initialX, currentY - initialY);
        context.beginPath();
        context.strokeStyle = 'blue';
        context.lineWidth = 5;
        context.arc(initialX, initialY, radius, (Math.PI/180)*0, (Math.PI/180)*360, false)
        context.stroke();
        context.closePath();
      },
      [LASSO_MODE]: function(context, lasso) {
        const {initialX, initialY, points = []} =  lasso;
        console.log('rendering lasso:', lasso);
        context.lineWidth = 4;
        context.strokeStyle =  'green';
        context.beginPath();
        context.moveTo(initialX, initialY);
        const coordinates =  points.map(Object.values).flat();
        for (let count = 0;  count < coordinates.length ;  count += 2) {
          context.lineTo(coordinates[count], coordinates[count  + 1]);
        }
        // TODO: Should starting point always connect to last point?
        context.lineTo(initialX, initialY);
        context.stroke();
        context.closePath();
      }
    };

    function byTimestamp(a, b) {
      return a.createdAt -  b.createdAt;
    }

    function draw() {
      const state = store.getState();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      state.items.sort(byTimestamp).forEach(function(item) {
        console.log(arguments);
        shapeRenderers[item.shape](ctx, item);
      });
    }


    const store = Redux.createStore(reducer);
    store.subscribe(draw);


    function switchRectangle() {
      store.dispatch({type: 'SHAPE_MODE', drawingShape: RECTANGLE_MODE});
    }

    function switchEllipse() {
      store.dispatch({type: 'SHAPE_MODE', drawingShape: ELLIPSE_MODE});
    }

    function  switchLasso() {
      store.dispatch({type: 'SHAPE_MODE', drawingShape: LASSO_MODE});

    }

    canvas.addEventListener('mousedown', function(event) {
      store.dispatch({type: 'DRAWING_MODE', drawingMode: true});

      const state = store.getState();
      console.log('drawing shape:', state.drawingShape);
      console.log('drawing mode:', state.drawingMode);
      store.dispatch({type: 'ADD_SHAPE', initialX: event.offsetX, initialY: event.offsetY});
    }, false);

    canvas.addEventListener('mousemove', function(event) {
      const state = store.getState();
      if (state.drawingMode) {
        store.dispatch({type: 'RESIZE_SHAPE', currentX: event.offsetX, currentY: event.offsetY});
      }

    }, false);

    canvas.addEventListener('mouseup', function(event) {
      store.dispatch({type: 'DRAWING_MODE', drawingMode: false});
      const state = store.getState();
      // TODO: if we need to immediately  store the shape, then export newly created shape as event
      console.log('mouse up - drawing mode:', state.drawingMode);
    }, false);

    draw();
</script>
</body>
</html>

