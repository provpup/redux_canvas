<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas width="800" height="700" id="drawingArea"  style="background: url('./sample3.jpg')"></canvas>
  <ul>
    <li><button onclick='switchRectangle()'>Rectangle</button></li>
    <li><button onclick='switchEllipse()'>Ellipse</button></li>
    <li><button onclick='switchLasso()'>Lasso</button></li>
    <li><button onclick='switchSelect()'>Select</button></li>
  </ul>
  <script>

    const RECTANGLE_MODE = 'rectangle';
    const ELLIPSE_MODE = 'ellipse';
    const LASSO_MODE = 'lasso';

    const closeEnough = 10;
    let dragTL = dragBL = dragTR = dragBR = false;
    let currentShape;

    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext('2d');

    const initialState = {
      activeSelection: null,
      canvas: { x: 0, y: 0 },
      items: [],
      xDragging: null,
      yDragging: null,
      draggingItemId: null,
      drawingShape: '',
      drawingMode: false,
      currentDrawingShapeInstance: '',
    };

    const shapeCopy = {
      [RECTANGLE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [ELLIPSE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [LASSO_MODE](source, currentX, currentY) {
        return { ...source, points: (source.points || []).concat({ x: currentX, y: currentY }) };
      },
    };

    function reducer(state, action) {
      if (state !== undefined) {
        const {
          canvas,
          currentDrawingShapeInstance,
          draggingItemId,
          items,
        } = state;
        const {
          activeSelection,
          initialX,
          initialY,
          currentX = initialX,
          currentY = initialY,
          drawingShape,
          drawingMode,
          id,
          type,
          xDragging,
          yDragging,
        } = action;
        switch (type) {
        case 'SHAPE_MODE':
          return { ...state, drawingShape };
        case 'DRAWING_MODE':
          return { ...state, drawingMode };
        case 'ADD_SHAPE':
          const newShape = {
            createdAt: Date.now(), shape: state.drawingShape, initialX, initialY,
          };
          return { ...state, items: items.concat(newShape), currentDrawingShapeInstance: newShape.createdAt };
        case 'RESIZE_SHAPE':
          // Get the current shape based on the saved timestamp
          currentShape = items.find(shape => shape.createdAt === currentDrawingShapeInstance);
          // We want to change the currentX and currentY for this shape in a functional way;
          // so we filter out the current shape from our list of shapes, and then add a new revised copy of our current shape with the new coordinates
          return { ...state, items: items.filter(shape => shape.createdAt !== currentDrawingShapeInstance).concat(shapeCopy[currentShape.shape](currentShape, currentX, currentY)) };
        case 'RESIZE_RECT_TR':
          currentShape = items.find(shape => shape.createdAt === state.activeSelection.createdAt);
          return { ...state, items: items.filter(shape => shape.createdAt !== currentShape.createdAt).concat(shapeCopy[currentShape.shape](currentShape, currentX, currentY)) };
        case 'SET_ACTIVE':
          return { ...state, activeSelection };
        case 'TRANSLATE_ITEM_START':
          return {
            ...state,
            xDragging,
            yDragging,
            draggingItemId: id,
          };
        case 'TRANSLATE_ITEM':
          const newItems = items.map((item) => {
            if (draggingItemId === item.createdAt) {
              if (item.shape === 'ellipse' || item.shape === 'rectangle') {
                return {
                  createdAt: item.createdAt,
                  initialX: item.initialX + xDragging - state.xDragging,
                  initialY: item.initialY + yDragging - state.yDragging,
                  currentX: item.currentX + xDragging - state.xDragging,
                  currentY: item.currentY + yDragging - state.yDragging,
                  shape: item.shape,
                };
              } if (item.shape === 'lasso') {
                return {
                  createdAt: item.createdAt,
                  initialX: item.initialX + xDragging - state.xDragging,
                  initialY: item.initialY + yDragging - state.yDragging,
                  points: item.points.map(point => ({ x: point.x + xDragging - state.xDragging, y: point.y + yDragging - state.yDragging })),
                  shape: item.shape,
                };
              }
            } else {
              return item;
            }
          });
          return {
            ...state,
            items: newItems,
            xDragging,
            yDragging,
            draggingItemId,
          };
        case 'TRANSLATE_ITEM_END':
          return {
            ...state,
            xDragging: null,
            yDragging: null,
            draggingItemId: null,
          };
        default:
          return state;
        }
      } else {
        return initialState;
      }
    }

    const shapeRenderers = {
      [RECTANGLE_MODE](context, rectangle) {
        const { initialX, initialY, currentX, currentY } = rectangle;
        const width = currentX - initialX;
        const height = currentY - initialY;
        context.lineWidth = 3;
        context.strokeStyle = 'red';
        context.rect(initialX, initialY, width, height);
      },
      [ELLIPSE_MODE](context, ellipse) {
        const { initialX, initialY, currentX, currentY } = ellipse;
        const radius = Math.hypot(currentX - initialX, currentY - initialY);
        context.strokeStyle = 'blue';
        context.lineWidth = 5;
        context.arc(initialX, initialY, radius, (Math.PI / 180) * 0, (Math.PI / 180) * 360, false);
      },
      [LASSO_MODE](context, lasso) {
        const { initialX, initialY, points = [] } = lasso;
        context.lineWidth = 1;
        context.strokeStyle = 'black';
        context.fillStyle = 'rgb(211, 211, 211, 0.3)';
        context.moveTo(initialX, initialY);
        const coordinates = points.map(Object.values).flat();
        for (let count = 0; count < coordinates.length; count += 2) {
          context.lineTo(coordinates[count], coordinates[count + 1]);
        }
        // close lasso
        context.closePath();
        context.fill();
      },
    };

    function byTimestamp(a, b) {
      return a.createdAt - b.createdAt;
    }

    function checkCloseEnough(p1, p2) {
        return Math.abs(p1 - p2) < closeEnough;
    }

    function checkCorners(event, item) {
      const { initialX, initialY, currentX, currentY } = item;
      const { offsetX, offsetY } = event;
      if (checkCloseEnough(offsetX, initialX) && checkCloseEnough(offsetY, initialY)) {
        dragBL = true;
        return;
      } else if (checkCloseEnough(offsetX, currentX) && checkCloseEnough(offsetY, initialY)) {
        dragBR = true;
        return;
      } else if (checkCloseEnough(offsetX, initialX) && checkCloseEnough(offsetY, currentY)) {
        dragTL = true;
        return;
      } else if (checkCloseEnough(offsetX, currentX) && checkCloseEnough(offsetY, currentY)) {
        dragTR = true;
        return;
      }
    }

    function drawRectangleHandles(state, item) {
      const { initialX, initialY, currentX, currentY, createdAt, shape } = item;
      if (state.activeSelection && createdAt === state.activeSelection.createdAt && shape === 'rectangle') {
        drawCircle(initialX, initialY, closeEnough); // bottom left
        drawCircle(currentX, currentY, closeEnough); // top right
        drawCircle(currentX, initialY, closeEnough); // bottom right
        drawCircle(initialX, currentY, closeEnough); // top left
      }
    }

    function drawCircle(x, y, radius) {
      ctx.fillStyle = "#FF0000";
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function draw() {
      const state = store.getState();
      console.log(state)
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      state.items.sort(byTimestamp).forEach((item) => {
        ctx.beginPath();
        shapeRenderers[item.shape](ctx, item);
        ctx.stroke();
        drawRectangleHandles(state, item);
      });
    }

    const store = Redux.createStore(reducer);
    store.subscribe(draw);

    function switchRectangle() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: RECTANGLE_MODE });
    }

    function switchEllipse() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: ELLIPSE_MODE });
    }

    function switchLasso() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: LASSO_MODE });
    }

    function switchSelect() {
      store.dispatch({ type: 'SHAPE_MODE', drawingShape: '' });
    }

    canvas.addEventListener('mousedown', (event) => {
      const { offsetX, offsetY } = event;
      const state = store.getState();
      store.dispatch({ type: 'DRAWING_MODE', drawingMode: true });
      if (state.drawingShape) {
        // Start creating a shape
        store.dispatch({ type: 'ADD_SHAPE', initialX: offsetX, initialY: offsetY });
        return;
      }
      // Select and drag shapes
      for (let i = state.items.length - 1; i >= 0; i--) {
        const item = state.items[i];
        checkCorners(event, item)
        ctx.beginPath();
        shapeRenderers[item.shape](ctx, item);
        if (ctx.isPointInPath(offsetX, offsetY)) {
          console.log('isPointInPath', item);
          store.dispatch({
            type: 'SET_ACTIVE',
            activeSelection: item,
          });
          store.dispatch({
            type: 'TRANSLATE_ITEM_START',
            id: item.createdAt,
            xDragging: offsetX,
            yDragging: offsetY,
          });
          return;
        } else {
          // store.dispatch({
          //   type: 'SET_ACTIVE',
          //   activeSelection: '',
          // });
        }
      }
    }, false);

    canvas.addEventListener('mousemove', (event) => {
      const { offsetX, offsetY } = event;
      const state = store.getState();
      if (dragTR) {
        store.dispatch({ type: 'RESIZE_RECT_TR', currentX: offsetX, currentY: offsetY});
      }
      if (state.drawingMode && state.drawingShape) {
        store.dispatch({ type: 'RESIZE_SHAPE', currentX: offsetX, currentY: offsetY });
      } else if (state.draggingItemId !== null) {
        store.dispatch({
          type: 'TRANSLATE_ITEM',
          xDragging: offsetX,
          yDragging: offsetY,
        });
      }
    }, false);

    canvas.addEventListener('mouseup', () => {
      const state = store.getState();
      store.dispatch({ type: 'TRANSLATE_ITEM_END' });
      store.dispatch({ type: 'DRAWING_MODE', drawingMode: false });
      dragTL = dragTR = dragBL = dragBR = false;
      // TODO: if we need to immediately  store the shape, then export newly created shape as event
    }, false);

    draw();
    </script>
  </body>
</html>