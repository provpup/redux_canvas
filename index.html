<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas id="drawingArea"></canvas>
  <ul>
    <li><button>Rectangle</button></li>
    <li><button>Ellipse</button></li>
    <li><button>Lasso</button></li>
  </ul>
  <script>
    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext("2d");
    const initialState = {
      canvas: { x: 0, y: 0 },
      items: [
        { id: 1, x: 10, y: 10, width: 50, height: 50, color: 'red' },
        { id: 2, x: 30, y: 30, width: 50, height: 50, color: 'blue' }
      ],
      xDragging: null,
      yDragging: null,
      draggingItemId: null
    };

    function reducer(state, action) {
      if (state !== undefined) {
        const {canvas, items, draggingItemId} = state;
        const {id, type, xDragging, yDragging} = action;
        console.log('reducer received action:', type);
        switch (type) {
          case 'TRANSLATE_CANVAS_START':
            return {canvas, items, xDragging, yDragging, draggingItemId: null};
          case 'TRANSLATE_CANVAS':
            return {
              canvas: {
                x: canvas.x + xDragging - state.xDragging,
                y: canvas.y + yDragging - state.yDragging
              },
              items, xDragging, yDragging, draggingItemId: null
            };
          case 'TRANSLATE_CANVAS_END':
            return {canvas, items, xDragging: null, yDragging: null, draggingItemId: null};
          case 'TRANSLATE_ITEM_START':
            return {canvas, items, xDragging, yDragging, draggingItemId: id};
          case 'TRANSLATE_ITEM':
            const newItems = items.map(function(item) {
              if (item.id === draggingItemId) {
                return {
                  id: item.id,
                  x: item.x + xDragging - state.xDragging,
                  y: item.y + yDragging - state.yDragging,
                  width: item.width,
                  height: item.height,
                  color: item.color
                };
              } else {
                return item;
              }
            });
            return {canvas, items: newItems, xDragging, yDragging, draggingItemId};
          case 'TRANSLATE_ITEM_END':
            return {canvas, items, xDragging: null, yDragging: null, draggingItemId: null};
          default:
            return state;
        }
      } else {
        return initialState;
      }
    }

    function draw() {
      const state = store.getState();
      ctx.setTransform(1, 0, 0, 1, 0, 0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      state.items.forEach(function(item) {
        ctx.fillStyle = item.color;
        ctx.fillRect(item.x, item.y, item.width, item.height);
      });
    }

    const store = Redux.createStore(reducer);
    store.subscribe(draw);

    canvas.addEventListener('mousedown', function(event) {
      var state = store.getState();
      for (var i = state.items.length - 1; i >= 0; i--) {
        var item = state.items[i];
        ctx.beginPath();
        ctx.rect(item.x, item.y, item.width, item.height);
        if (ctx.isPointInPath(event.offsetX, event.offsetY)) {
          store.dispatch({
            type: 'TRANSLATE_ITEM_START',
            id: item.id,
            xDragging: event.offsetX,
            yDragging: event.offsetY
          });
          return;
        }
      }
      store.dispatch({
        type: 'TRANSLATE_CANVAS_START',
        xDragging: event.offsetX,
        yDragging: event.offsetY
      });
    }, false);

    canvas.addEventListener('mousemove', function(event) {
      var state = store.getState();
      if (state.draggingItemId !== null) {
        store.dispatch({
          type: 'TRANSLATE_ITEM',
          xDragging: event.offsetX,
          yDragging: event.offsetY
        });
      } else if (state.xDragging !== null && state.yDragging !== null) {
        store.dispatch({
          type: 'TRANSLATE_CANVAS',
          xDragging: event.offsetX,
          yDragging: event.offsetY
        });
      }
    }, false);

    canvas.addEventListener('mouseup', function(event) {
      var state = store.getState();
      store.dispatch({type: state.draggingItemId !== null ? 'TRANSLATE_ITEM_END' : 'TRANSLATE_CANVAS_END'});
    }, false);

    draw();
</script>
</body>
</html>

