<!DOCTYPE html>
<head>
  <meta charset="UTF-8">
  <title>Canvas example</title>
  <script src="https://unpkg.com/redux@latest/dist/redux.min.js"></script>
</head>
<body>
  <canvas width="600" height="400" id="drawingArea"  style="background: url('./cat_caviar.jpg')"></canvas>
  <ul>
    <li><button onclick='switchLine()'>Line</button></li>
    <li><button onclick='switchRectangle()'>Rectangle</button></li>
    <li><button onclick='switchEllipse()'>Ellipse</button></li>
    <li><button onclick='switchLasso()'>Lasso</button></li>
    <li><button onclick='switchSelect()'>Select</button></li>
  </ul>
  <script>
    // Constants
    const RECTANGLE_MODE = 'rectangle';
    const ELLIPSE_MODE = 'ellipse';
    const LASSO_MODE = 'lasso';
    const LINE_MODE = 'line';
    const SELECT_MODE = 'select';

    const ADD_SHAPE = 'ADD_SHAPE';
    const CLEAR_ACTIVE_SELECTION = 'CLEAR_ACTIVE_SELECTION';
    const CLEAR_CURRENT_DRAWING_SHAPE = 'CLEAR_CURRENT_DRAWING_SHAPE';
    const DRAG_CORNER_HANDLE = 'DRAG_CORNER_HANDLE';
    const DRAWING_MODE = 'DRAWING_MODE';
    const RESIZE_RECT_OR_ELLIPSE = 'RESIZE_RECT_OR_ELLIPSE';
    const RESIZE_SELECTION_BOX = 'RESIZE_SELECTION_BOX';
    const RESIZE_SHAPE = 'RESIZE_SHAPE';
    const SELECT_BOX = 'SELECT_BOX';
    const SELECT_BOX_END = 'SELECT_BOX_END';
    const SET_ACTIVE = 'SET_ACTIVE';
    const SHAPE_MODE = 'SHAPE_MODE';
    const TRANSLATE_ITEM = 'TRANSLATE_ITEM';
    const TRANSLATE_ITEM_START = 'TRANSLATE_ITEM_START';
    const TRANSLATE_ITEM_END = 'TRANSLATE_ITEM_END';

    const handleHitBox = 10;
    let currentShape;

    const canvas = document.getElementById('drawingArea');
    const ctx = canvas.getContext('2d');

    const initialState = {
      activeSelection: [],
      canvas: { x: 0, y: 0 },
      currentDrawingShapeInstance: '',
      dragBL: false,
      dragBR: false,
      dragTL: false,
      dragTR: false,
      dragMiddle: false,
      draggingItemId: null,
      drawingShape: '',
      drawingMode: false,
      items: [],
      selectionBox: null,
      xDragging: null,
      yDragging: null,
    };

    function reducer(state, action) {
      if (state !== undefined) {
        const {
          currentDrawingShapeInstance,
          draggingItemId,
          items,
        } = state;
        const {
          activeSelection,
          initialX,
          initialY,
          corner,
          currentX = initialX,
          currentY = initialY,
          dragging,
          drawingShape,
          drawingMode,
          handle,
          id,
          type,
          xDragging,
          yDragging,
        } = action;
        switch (type) {
        case SHAPE_MODE:
          return { ...state, drawingShape };
        case CLEAR_CURRENT_DRAWING_SHAPE:
          return { ...state, currentDrawingShapeInstance: '' };
        case CLEAR_ACTIVE_SELECTION:
          return { ...state, activeSelection: [] };
        case DRAWING_MODE:
          return { ...state, drawingMode };
        case DRAG_CORNER_HANDLE:
          return { ...state, [handle]: dragging, xDragging, yDragging };
        case ADD_SHAPE:
          const newShape = {
            createdAt: Date.now(), shape: state.drawingShape, initialX, initialY,
          };
          return { ...state, currentDrawingShapeInstance: newShape.createdAt, items: items.concat(newShape) };
        case SELECT_BOX:
          const selectionBox = {
            shape: state.drawingShape, initialX, initialY,
          };
          return { ...state, selectionBox };
        case RESIZE_SELECTION_BOX:
          return { ...state, selectionBox: shapeInitialResize[SELECT_MODE](state.selectionBox, currentX, currentY) };
        case SELECT_BOX_END:
          return { ...state, selectionBox: null };
        case RESIZE_SHAPE:
          // Get the current shape based on the saved timestamp
          currentShape = items.find(shape => shape.createdAt === currentDrawingShapeInstance);
          // We want to change the currentX and currentY for this shape in a functional way;
          // so we filter out the current shape from our list of shapes, and then add a new revised copy of our current shape with the new coordinates
          return { ...state, items: items.filter(shape => shape.createdAt !== currentDrawingShapeInstance).concat(shapeInitialResize[currentShape.shape](currentShape, currentX, currentY)) };
        case RESIZE_RECT_OR_ELLIPSE:
          const updatedShapes = state.items.map((shape) => {
            const found = action.activeSelection.find(el => el.createdAt === shape.createdAt);
            if (found) {
              return shapeResize[RECTANGLE_MODE](shape, currentX - state.xDragging, currentY - state.yDragging, corner);
            }
            return shape;
          });
          return { ...state, items: updatedShapes, xDragging: currentX, yDragging: currentY };
        case SET_ACTIVE:
          return { ...state, activeSelection: state.activeSelection.concat(activeSelection) };
        case TRANSLATE_ITEM_START:
          return {
            ...state,
            xDragging,
            yDragging,
            draggingItemId: id,
          };
        case TRANSLATE_ITEM:
          const translatedShapes = state.items.map((shape) => {
            const found = action.activeSelection.find(el => el.createdAt === shape.createdAt);
            if (found) {
              return shapeTranslate[found.shape](shape, xDragging - state.xDragging, yDragging - state.yDragging);
            } return shape;
          });
          return {
            ...state, draggingItemId, items: translatedShapes, xDragging, yDragging,
          };
        case TRANSLATE_ITEM_END:
          return {
            ...state,
            xDragging: null,
            yDragging: null,
            draggingItemId: null,
          };
        default:
          return state;
        }
      } else {
        return initialState;
      }
    }

    const shapeRenderers = {
      [SELECT_MODE](context, select) {
        if (select === null) {
          return;
        }
        const {
          initialX, initialY, currentX, currentY,
        } = select;
        const width = currentX - initialX;
        const height = currentY - initialY;
        context.save();
        context.rect(initialX, initialY, width, height);
        context.lineWidth = 3;
        context.strokeStyle = 'yellow';
        context.stroke();
        context.restore();
      },
      [LINE_MODE](context, line) {
        const {
          initialX, initialY, currentX, currentY,
        } = line;
        context.save();
        context.moveTo(initialX, initialY);
        context.lineTo(currentX, currentY);
        context.lineWidth = 3;
        context.strokeStyle = 'green';
        context.stroke();
        context.restore();
      },
      [RECTANGLE_MODE](context, rectangle) {
        const {
          initialX, initialY, currentX, currentY,
        } = rectangle;
        const width = currentX - initialX;
        const height = currentY - initialY;
        context.save();
        context.rect(initialX, initialY, width, height);
        context.lineWidth = 3;
        context.strokeStyle = 'red';
        context.stroke();
        context.restore();
      },
      [ELLIPSE_MODE](context, ellipse) {
        const {
          initialX, initialY, currentX, currentY,
        } = ellipse;
        const scalex = 1 * ((currentX - initialX) / 2);
        const scaley = 1 * ((currentY - initialY) / 2);
        const centerx = (initialX / scalex) + 1;
        const centery = (initialY / scaley) + 1;
        context.save();
        context.scale(scalex, scaley);
        context.arc(centerx, centery, 1, 0, 2 * Math.PI);
        context.restore();
        context.save();
        context.strokeStyle = 'blue';
        context.lineWidth = 4;
        context.stroke();
        context.restore();
      },
      [LASSO_MODE](context, lasso) {
        const { points = [] } = lasso;
        const coordinates = points.map(Object.values).flat();
        for (let count = 0; count < coordinates.length; count += 2) {
          context.lineTo(coordinates[count], coordinates[count + 1]);
        }
        context.save();
        context.lineWidth = 2;
        context.strokeStyle = 'black';
        context.fillStyle = 'rgb(0, 0, 0, 0.4)';
        context.closePath();
        context.fill();
        context.restore();
      },
    };

    const shapeInitialResize = {
      [SELECT_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [LINE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [RECTANGLE_MODE](source, currentX, currentY, corner) {
        return { ...source, currentX, currentY };
      },
      [ELLIPSE_MODE](source, currentX, currentY) {
        return { ...source, currentX, currentY };
      },
      [LASSO_MODE](source, currentX, currentY) {
        return { ...source, points: (source.points || []).concat({ x: currentX, y: currentY }) };
      },
    };

    const shapeResize = {
      [RECTANGLE_MODE](source, currentX, currentY, corner) {
        if (corner === 'TL') {
          return { ...source, initialX: source.initialX + currentX, currentY: source.currentY + currentY };
        } if (corner === 'BR') {
          return { ...source, currentX: source.currentX + currentX, initialY: source.initialY + currentY };
        } if (corner === 'BL') {
          return { ...source, initialX: source.initialX + currentX, initialY: source.initialY + currentY };
        } if (corner === 'TR') {
          return { ...source, currentX: source.currentX + currentX, currentY: source.currentY + currentY };
        }
        return { ...source, currentX, currentY }
      }
    }

    const shapeTranslate = {
      [LINE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const {
          initialX, initialY, currentX, currentY,
        } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference,
        };
      },
      [RECTANGLE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const {
          initialX, initialY, currentX, currentY,
        } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference,
        };
      },
      [ELLIPSE_MODE](source, xDraggingDifference, yDraggingDifference) {
        const {
          initialX, initialY, currentX, currentY,
        } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          currentX: currentX + xDraggingDifference,
          currentY: currentY + yDraggingDifference,
        };
      },
      [LASSO_MODE](source, xDraggingDifference, yDraggingDifference) {
        const { initialX, initialY, points } = source;
        return {
          ...source,
          initialX: initialX + xDraggingDifference,
          initialY: initialY + yDraggingDifference,
          points: points.map(point => ({ x: point.x + xDraggingDifference, y: point.y + yDraggingDifference })),
        };
      },
    };


    function byTimestamp(a, b) {
      return a.createdAt - b.createdAt;
    }

    function checkHandleHitBox(p1, p2) {
      return Math.abs(p1 - p2) < 20;
    }

    function checkCorners(event, item) {
      const state = store.getState();
      const {
        initialX, initialY, currentX, currentY,
      } = item;
      const { offsetX, offsetY } = event;
      if (state.activeSelection.length && state.activeSelection.find(x => (x.createdAt === item.createdAt))) {
        if (checkHandleHitBox(offsetX, initialX) && checkHandleHitBox(offsetY, initialY)) {
          store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragBL', dragging: true, xDragging: offsetX, yDragging: offsetY });
          return;
        } if (checkHandleHitBox(offsetX, currentX) && checkHandleHitBox(offsetY, initialY)) {
          store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragBR', dragging: true, xDragging: offsetX, yDragging: offsetY });
        } else if (checkHandleHitBox(offsetX, initialX) && checkHandleHitBox(offsetY, currentY)) {
          store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragTL', dragging: true, xDragging: offsetX, yDragging: offsetY });
        } else if (checkHandleHitBox(offsetX, currentX) && checkHandleHitBox(offsetY, currentY)) {
          store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragTR', dragging: true, xDragging: offsetX, yDragging: offsetY });
        } else if (checkHandleHitBox(offsetX, (currentX + initialX) / 2) && checkHandleHitBox(offsetY, (currentY + initialY) / 2)) {
          store.dispatch({
            type: TRANSLATE_ITEM_START, id: item.createdAt, xDragging: offsetX, yDragging: offsetY,
          });
        }
      }
    }

    function checkDraggingHandles(event, state) {
      const {
        activeSelection, dragBL, dragBR, dragTL, dragTR, draggingItemId,
      } = state;
      const { offsetX, offsetY } = event;
      if (dragTR) {
        store.dispatch({
          type: RESIZE_RECT_OR_ELLIPSE, currentX: offsetX, currentY: offsetY, corner: 'TR', activeSelection,
        });
        return;
      }
      if (dragTL) {
        store.dispatch({
          type: RESIZE_RECT_OR_ELLIPSE, currentX: offsetX, currentY: offsetY, corner: 'TL', activeSelection,
        });
        return;
      }
      if (dragBL) {
        store.dispatch({
          type: RESIZE_RECT_OR_ELLIPSE, currentX: offsetX, currentY: offsetY, corner: 'BL', activeSelection,
        });
        return;
      }
      if (dragBR) {
        store.dispatch({
          type: RESIZE_RECT_OR_ELLIPSE, currentX: offsetX, currentY: offsetY, corner: 'BR', activeSelection,
        });
        return;
      }
      if (draggingItemId) {
        store.dispatch({
          type: TRANSLATE_ITEM, activeSelection, xDragging: offsetX, yDragging: offsetY,
        });
      }
    }

    function drawRectangleEllipseHandles(state, item) {
      const {
        initialX, initialY, currentX, currentY, createdAt, shape,
      } = item;
      if (state.activeSelection.length && state.activeSelection.find(x => x.createdAt === createdAt) && (shape === RECTANGLE_MODE || shape === ELLIPSE_MODE || shape === LINE_MODE)) {
        drawCircle(initialX, initialY, handleHitBox); // bottom left
        drawCircle(currentX, currentY, handleHitBox); // top right
        drawCircle(currentX, initialY, handleHitBox); // bottom right
        drawCircle(initialX, currentY, handleHitBox); // top left
        drawSquare(((currentX + initialX) / 2) - 10, ((currentY + initialY) / 2) - 10); // middle
      }
    }

    function drawCircle(x, y, radius) {
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.arc(x, y, radius, 0, 2 * Math.PI);
      ctx.fill();
    }

    function drawSquare(x, y) {
      ctx.fillStyle = '#FF0000';
      ctx.beginPath();
      ctx.fillRect(x, y, 20, 20);
    }

    function draw() {
      const state = store.getState();
      ctx.setTransform(1, 0, 0, 1, state.canvas.x, state.canvas.y);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (state.drawingShape === SELECT_MODE) {
        ctx.beginPath();
        shapeRenderers[SELECT_MODE](ctx, state.selectionBox);
      }
      state.items.sort(byTimestamp).forEach((item) => {
        ctx.beginPath();
        shapeRenderers[item.shape](ctx, item);
        drawRectangleEllipseHandles(state, item);
      });
    }

    function getOverlapped() {
      const state = store.getState();
      const { selectionBox } = state;
      if (selectionBox === null) {
        return;
      }
      // Check to see if any shapes are contained within the selection box. The corners of the
      // selection box depend on which direction the box was drawn. (left to right, top to bottom, etc)

      // Check bottom right to top left
      function checkBRtoTL(item) {
        return (selectionBox.initialX >= item.initialX && selectionBox.currentX <= item.currentX)
            && (selectionBox.initialY >= item.initialY && selectionBox.currentY <= item.currentY);
      }

      // Check top left to bottom right
      function checkTLtoBR(item) {
        return (selectionBox.initialX <= item.initialX && selectionBox.currentX >= item.currentX)
            && (selectionBox.initialY <= item.initialY && selectionBox.currentY >= item.currentY);
      }

      // Check top right to bottom left
      function checkTRtoBL(item) {
        return (selectionBox.initialX <= item.initialX && selectionBox.currentX >= item.currentX)
            && (selectionBox.initialY >= item.initialY && selectionBox.currentY <= item.currentY);
      }

      // Check bottom left to top right
      function checkBLtoTR(item) {
        return (selectionBox.initialX >= item.initialX && selectionBox.currentX <= item.currentX)
            && (selectionBox.initialY <= item.initialY && selectionBox.currentY >= item.currentY);
      }

      for (let i = 0; i < state.items.length; i++) {
        const item = state.items[i];
        if (checkBRtoTL(item) || checkTLtoBR(item) || checkTRtoBL(item) || checkBLtoTR(item)) {
          store.dispatch({ type: SET_ACTIVE, activeSelection: item });
        }
      }
    }

    function switchEllipse() {
      store.dispatch({ type: SHAPE_MODE, drawingShape: ELLIPSE_MODE });
    }

    function switchLasso() {
      store.dispatch({ type: SHAPE_MODE, drawingShape: LASSO_MODE });
    }

    function switchLine() {
      store.dispatch({ type: SHAPE_MODE, drawingShape: LINE_MODE });
    }

    function switchRectangle() {
      store.dispatch({ type: SHAPE_MODE, drawingShape: RECTANGLE_MODE });
    }

    function switchSelect() {
      store.dispatch({ type: SHAPE_MODE, drawingShape: SELECT_MODE });
    }

    canvas.addEventListener('mousedown', (event) => {
      const { offsetX, offsetY } = event;
      const state = store.getState();
      const {
        activeSelection, drawingShape, items,
      } = state;
      store.dispatch({ type: DRAWING_MODE, drawingMode: true });
      if (drawingShape && drawingShape !== SELECT_MODE) {
        // Start creating a shape
        store.dispatch({ type: ADD_SHAPE, initialX: offsetX, initialY: offsetY });
        return;
      }
      if (activeSelection.length) {
        // Select and drag shapes
        for (let i = items.length - 1; i >= 0; i--) {
          const item = items[i];
          checkCorners(event, item);
        }
        return;
      }
      if (drawingShape === SELECT_MODE) {
        store.dispatch({ type: SELECT_BOX, initialX: offsetX, initialY: offsetY });
      }
    }, false);

    canvas.addEventListener('mousemove', (event) => {
      const state = store.getState();
      const { offsetX, offsetY } = event;
      checkDraggingHandles(event, state);
      if (state.drawingMode && state.drawingShape === SELECT_MODE) {
        store.dispatch({ type: RESIZE_SELECTION_BOX, currentX: offsetX, currentY: offsetY });
        return;
      }
      if (state.drawingMode && state.drawingShape !== SELECT_MODE && state.currentDrawingShapeInstance) {
        store.dispatch({ type: RESIZE_SHAPE, currentX: offsetX, currentY: offsetY });
      }
    }, false);

    canvas.addEventListener('mouseup', () => {
      const state = store.getState();
      const {
        xDragging, dragTR, dragTL, dragBR, dragBL,
      } = state;
      // Clear active selection on mouse up if not dragging or resizing a shape
      if (!xDragging && !dragTR && !dragTL && !dragBR && !dragBL) {
        store.dispatch({ type: CLEAR_ACTIVE_SELECTION });
      }
      store.dispatch({ type: TRANSLATE_ITEM_END });
      store.dispatch({ type: DRAWING_MODE, drawingMode: false });
      store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragTR', dragging: false });
      store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragTL', dragging: false });
      store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragBR', dragging: false });
      store.dispatch({ type: DRAG_CORNER_HANDLE, handle: 'dragBL', dragging: false });
      getOverlapped();
      store.dispatch({ type: SELECT_BOX_END });
      store.dispatch({ type: CLEAR_CURRENT_DRAWING_SHAPE });
      // TODO: if we need to immediately  store the shape, then export newly created shape as event
    }, false);

    const store = Redux.createStore(reducer);
    store.subscribe(draw);

    draw();

    </script>
  </body>
</html>